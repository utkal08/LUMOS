Next Larger element in n-ary tree
Read
Discuss
Courses
Practice
Video
Given a generic tree and a integer x. Find and return the node with next larger element in the tree i.e. find a node just greater than x. Return NULL if no node is present with value greater than x. 
For example, in the given tree
 x = 10, just greater node value is 12
Recommended: Please try your approach on {IDE} first, before moving on to the solution.
The idea is maintain a node pointer res, which will contain the final resultant node. 
Traverse the tree and check if root data is greater than x. If so, then compare the root data with res data. 
If root data is greater than n and less than res data update res.
Implementation:
C++



// CPP program to find next larger element
// in an n-ary tree.
#include <bits/stdc++.h>
using namespace std;
  // Structure of a node of an n-ary tree
struct Node {
    int key;
    vector<Node*> child;
};
  // Utility function to create a new tree node
Node* newNode(int key)
{
    Node* temp = new Node;
    temp->key = key;
    return temp;
}
  void nextLargerElementUtil(Node* root, int x, Node** res)
{
    if (root == NULL)
        return;
      // if root is less than res but greater than 
    // x update res
    if (root->key > x) 
        if (!(*res) || (*res)->key > root->key)
            *res = root;    
      // Number of children of root
    int numChildren = root->child.size();
      // Recur calling for every child
    for (int i = 0; i < numChildren; i++)
        nextLargerElementUtil(root->child[i], x, res);
      return;
}
  // Function to find next Greater element of x in tree
Node* nextLargerElement(Node* root, int x)
{
    // resultant node
    Node* res = NULL;
      // calling helper function
    nextLargerElementUtil(root, x, &res);
      return res;
}
  // Driver program
int main()
{
    /*   Let us create below tree
   *             5
   *         /   |  \
   *         1   2   3
   *        /   / \   \
   *       15  4   5   6
   */
      Node* root = newNode(5);
    (root->child).push_back(newNode(1));
    (root->child).push_back(newNode(2));
    (root->child).push_back(newNode(3));
    (root->child[0]->child).push_back(newNode(15));
    (root->child[1]->child).push_back(newNode(4));
    (root->child[1]->child).push_back(newNode(5));
    (root->child[2]->child).push_back(newNode(6));
      int x = 5;
      cout << "Next larger element of " << x << " is ";
    cout << nextLargerElement(root, x)->key << endl;
      return 0;
}
Java



// Java program to find next larger element
// in an n-ary tree.
import java.util.*;
  class GFG
{
  // Structure of a node of an n-ary tree
static class Node
{
    int key;
    Vector<Node> child;
};
static Node res;
  // Utility function to create a new tree node
static Node newNode(int key)
{
    Node temp = new Node();
    temp.key = key;
    temp.child = new Vector<>();
    return temp;
}
  static void nextLargerElementUtil(Node root, int x)
{
    if (root == null)
        return;
      // if root is less than res but 
    // greater than x, update res
    if (root.key > x) 
        if ((res == null || (res).key > root.key))
            res = root; 
      // Number of children of root
    int numChildren = root.child.size();
      // Recur calling for every child
    for (int i = 0; i < numChildren; i++)
        nextLargerElementUtil(root.child.get(i), x);
      return;
}
  // Function to find next Greater element 
// of x in tree
static Node nextLargerElement(Node root, int x)
{
    // resultant node
    res = null;
      // calling helper function
    nextLargerElementUtil(root, x);
      return res;
}
  // Driver Code
public static void main(String[] args)
{
    /* Let us create below tree
    *             5
    *         / | \
    *         1 2 3
    *     / / \ \
    *     15 4 5 6
    */
    Node root = newNode(5);
    (root.child).add(newNode(1));
    (root.child).add(newNode(2));
    (root.child).add(newNode(3));
    (root.child.get(0).child).add(newNode(15));
    (root.child.get(1).child).add(newNode(4));
    (root.child.get(1).child).add(newNode(5));
    (root.child.get(2).child).add(newNode(6));
      int x = 5;
      System.out.print("Next larger element of " +
                                    x + " is ");
    System.out.print(nextLargerElement(root, x).key + "\n");
  }
}
  // This code is contributed by 29AjayKumar
Python3



# Python program to find next larger element
# in an n-ary tree.
class Node:
   # Structure of a node of an n-ary tree
    def __init__(self):
        self.key = 0
        self.child = []
  # Utility function to create a new tree node
def newNode(key):
    temp = Node()
    temp.key = key
    temp.child = []
    return temp
  res = None;    
def nextLargerElementUtil(root,x):
    global res
    if (root == None):
        return;
           # if root is less than res but 
    # greater than x, update res
    if (root.key > x):
        if ((res == None or (res).key > root.key)):
            res = root;
                  # Number of children of root
    numChildren = len(root.child)
           # Recur calling for every child
    for i in range(numChildren):
        nextLargerElementUtil(root.child[i], x)
    return
    # Function to find next Greater element 
# of x in tree
def nextLargerElement(root,x):
       # resultant node
    global res
    res=None
          # Calling helper function
    nextLargerElementUtil(root, x)
          return res
          # Driver code
root = newNode(5)
(root.child).append(newNode(1))
(root.child).append(newNode(2))
(root.child).append(newNode(3))
(root.child[0].child).append(newNode(15))
(root.child[1].child).append(newNode(4))
(root.child[1].child).append(newNode(5))
(root.child[2].child).append(newNode(6))
  x = 5
print("Next larger element of " , x , " is ",end='')
print(nextLargerElement(root, x).key)
  # This code is contributed by rag2127.
C#



// C# program to find next larger element
// in an n-ary tree.
using System;
using System.Collections.Generic;
  class GFG
{
  // Structure of a node of an n-ary tree
class Node
{
    public int key;
    public List<Node> child;
};
static Node res;
  // Utility function to create a new tree node
static Node newNode(int key)
{
    Node temp = new Node();
    temp.key = key;
    temp.child = new List<Node>();
    return temp;
}
  static void nextLargerElementUtil(Node root, 
                                  int x)
{
    if (root == null)
        return;
      // if root is less than res but 
    // greater than x, update res
    if (root.key > x) 
        if ((res == null || 
            (res).key > root.key))
            res = root; 
      // Number of children of root
    int numChildren = root.child.Count;
      // Recur calling for every child
    for (int i = 0; i < numChildren; i++)
        nextLargerElementUtil(root.child[i], x);
      return;
}
  // Function to find next Greater element 
// of x in tree
static Node nextLargerElement(Node root,    
                                  int x)
{
    // resultant node
    res = null;
      // calling helper function
    nextLargerElementUtil(root, x);
      return res;
}
  // Driver Code
public static void Main(String[] args)
{
    /* Let us create below tree
    *             5
    *         / | \
    *         1 2 3
    *     / / \ \
    *     15 4 5 6
    */
    Node root = newNode(5);
    (root.child).Add(newNode(1));
    (root.child).Add(newNode(2));
    (root.child).Add(newNode(3));
    (root.child[0].child).Add(newNode(15));
    (root.child[1].child).Add(newNode(4));
    (root.child[1].child).Add(newNode(5));
    (root.child[2].child).Add(newNode(6));
      int x = 5;
      Console.Write("Next larger element of " +
                                 x + " is ");
    Console.Write(nextLargerElement(root, x).key + "\n");
}
}
  // This code is contributed by PrinciRaj1992
Javascript



  // JavaScript program to find next larger element
// in an n-ary tree.
  // Structure of a node of an n-ary tree
class Node
{
    constructor()
    {
        this.key = 0;
        this.child = [];
    }
};
  var res = null;
  // Utility function to create a new tree node
function newNode(key)
{
    var temp = new Node();
    temp.key = key;
    temp.child = [];
    return temp;
}
  function nextLargerElementUtil(root, x)
{
    if (root == null)
        return;
      // if root is less than res but 
    // greater than x, update res
    if (root.key > x) 
        if ((res == null || 
            (res).key > root.key))
            res = root; 
      // Number of children of root
    var numChildren = root.child.length;
      // Recur calling for every child
    for (var i = 0; i < numChildren; i++)
        nextLargerElementUtil(root.child[i], x);
      return;
}
  // Function to find next Greater element 
// of x in tree
function nextLargerElement(root,  x)
{
    // resultant node
    res = null;
      // calling helper function
    nextLargerElementUtil(root, x);
      return res;
}
  // Driver Code
/* Let us create below tree
*             5
*         / | \
*         1 2 3
*     / / \ \
*     15 4 5 6
*/
var root = newNode(5);
(root.child).push(newNode(1));
(root.child).push(newNode(2));
(root.child).push(newNode(3));
(root.child[0].child).push(newNode(15));
(root.child[1].child).push(newNode(4));
(root.child[1].child).push(newNode(5));
(root.child[2].child).push(newNode(6));
var x = 5;
document.write("Next larger element of " +
                             x + " is ");
document.write(nextLargerElement(root, x).key + "<br>");
    Output
Next larger element of 5 is 6
Time complexity :- O(N)
Space complexity :- O(H)
Example no2:
Algorithmic steps:
Traverse the tree in post-order and store the nodes in a stack.
Create an empty hash map to store the next larger element for each node.
For each node in the stack, pop it from the stack and find the next larger element for it by checking the elements on the top of the stack. If an element on the top of the stack is greater than the current node, it is the next larger element for the current node. Keep popping elements from the stack until the top of the stack is less than or equal to the current node.
Add the next larger element for the current node to the hash map.
Repeat steps 3 and 4 until the stack is empty.
Return the next larger element for the target node by looking it up in the hash map.
  Note: This algorithm assumes that the tree is a binary search tree, where the value of each node is greater than the values of its left child and less than the values of its right child. If the tree is not a binary search tree, the above algorithm may not give correct result
Program: Implementing by Postorder traversing tree:
C++



#include <iostream>
#include <stack>
#include <unordered_map>
  struct TreeNode {
    int val;
    vector<TreeNode*> children;
    TreeNode(int x) : val(x) {}
};
  void postOrder(TreeNode *root, stack<int> &nodes) {
    if (!root) return;
    for (int i = 0; i < root->children.size(); i++) {
        postOrder(root->children[i], nodes);
    }
    nodes.push(root->val);
}
  unordered_map<int, int> findNextLarger(TreeNode *root) {
    stack<int> nodes;
    unordered_map<int, int> nextLarger;
    postOrder(root, nodes);
      while (!nodes.empty()) {
        int current = nodes.top();
        nodes.pop();
        while (!nodes.empty() && nodes.top() <= current) {
            nodes.pop();
        }
        if (!nodes.empty()) {
            nextLarger[current] = nodes.top();
        } else {
            nextLarger[current] = -1;
        }
    }
      return nextLarger;
}
  int main() {
    TreeNode *root = new TreeNode(8);
    root->children.push_back(new TreeNode(3));
    root->children.push_back(new TreeNode(10));
    root->children[0]->children.push_back(new TreeNode(1));
    root->children[0]->children.push_back(new TreeNode(6));
    root->children[0]->children[1]->children.push_back(new TreeNode(4));
    root->children[0]->children[1]->children.push_back(new TreeNode(7));
    root->children[1]->children.push_back(new TreeNode(14));
      int target = 4;
    unordered_map<int, int> nextLarger = findNextLarger(root);
    cout << "The next larger element for " << target << " is: " << nextLarger[target] << endl;
    return 0;
}
Java



import java.util.*;
  class TreeNode {
    int val;
    List<TreeNode> children;
      TreeNode(int x) {
        val = x;
        children = new ArrayList<>();
    }
}
  public class Main {
    static void postOrder(TreeNode root, Stack<Integer> nodes) {
        if (root == null)
            return;
        for (TreeNode child : root.children) {
            postOrder(child, nodes);
        }
        nodes.push(root.val);
    }
      static Map<Integer, Integer> findNextLarger(TreeNode root) {
        Stack<Integer> nodes = new Stack<>();
        Map<Integer, Integer> nextLarger = new HashMap<>();
        postOrder(root, nodes);
          Stack<Integer> stack = new Stack<>();
        for (int i = nodes.size() - 1; i >= 0; i--) {
            while (!stack.isEmpty() && stack.peek() <= nodes.get(i)) {
                stack.pop();
            }
            nextLarger.put(nodes.get(i), stack.isEmpty() ? -1 : stack.peek());
            stack.push(nodes.get(i));
        }
          return nextLarger;
    }
      public static void main(String[] args) {
        TreeNode root = new TreeNode(8);
        root.children = new ArrayList<>();
        root.children.add(new TreeNode(3));
        root.children.add(new TreeNode(10));
        root.children.get(0).children = new ArrayList<>();
        root.children.get(0).children.add(new TreeNode(1));
        root.children.get(0).children.add(new TreeNode(6));
        root.children.get(0).children.get(1).children = new ArrayList<>();
        root.children.get(0).children.get(1).children.add(new TreeNode(4));
        root.children.get(0).children.get(1).children.add(new TreeNode(7));
        root.children.get(1).children = new ArrayList<>();
        root.children.get(1).children.add(new TreeNode(14));
          int target = 4;
        Map<Integer, Integer> nextLarger = findNextLarger(root);
        Integer nextLargerValue = nextLarger.get(target);
        System.out.println("The next larger element for " + target + " is: " + (nextLargerValue != null ? nextLargerValue : -1));
    }
}
Python3



class Node:
    # Structure of a node of an n-ary tree
    def __init__(self):
        self.vcal = 0
        self.children = []
  # Utility function to create a new tree node
    def newNode(val):
    temp = Node()
    temp.val = val
    temp.children = []
    return temp
    def postOrder(root, nodes):
    if not root:
        return
    for child in root.children:
        postOrder(child, nodes)
    nodes.append(root.val)
    def findNextLarger(root):
    nodes = []
    nextLarger = {}
    postOrder(root, nodes)
      stack = []
    for num in nodes[::-1]:
        while stack and stack[-1] <= num:
            stack.pop()
        nextLarger[num] = stack[-1] if stack else -1
        stack.append(num)
      return nextLarger
    root = newNode(8)
root.children.append(newNode(3))
root.children.append(newNode(10))
root.children[0].children.append(newNode(1))
root.children[0].children.append(newNode(6))
root.children[0].children[1].children.append(newNode(4))
root.children[0].children[1].children.append(newNode(7))
root.children[1].children.append(newNode(14))
  target = 4
nextLarger = findNextLarger(root)
print(f"The next larger element for {target} is: {nextLarger[target]}")
C#



using System;
using System.Collections.Generic;
  class Node {
    // Structure of a node of an n-ary tree
    public int val;
    public List<Node> children;
      public Node()
    {
        val = 0;
        children = new List<Node>();
    }
}
  public class MainClass {
    // Utility function to create a new tree node
    static Node NewNode(int val)
    {
        Node temp = new Node();
        temp.val = val;
        temp.children = new List<Node>();
        return temp;
    }
      // Function to perform post-order traversal and store
    // nodes in a list
    static void PostOrder(Node root, List<int> nodes)
    {
        if (root == null)
            return;
          // Recursively perform post-order traversal for each
        // child node
        foreach(Node child in root.children)
        {
            PostOrder(child, nodes);
        }
          // Add the current node value to the list after
        // processing all its children
        nodes.Add(root.val);
    }
      // Function to find the next larger element for each
    // node in the tree
    static Dictionary<int, int> FindNextLarger(Node root)
    {
        List<int> nodes = new List<int>();
        Dictionary<int, int> nextLarger
            = new Dictionary<int, int>();
        PostOrder(root, nodes);
          Stack<int> stack = new Stack<int>();
        for (int i = nodes.Count - 1; i >= 0; i--) {
            // Keep popping elements from the end of the
            // list until we find the next larger element
            while (stack.Count > 0
                   && stack.Peek() <= nodes[i]) {
                stack.Pop();
            }
              // If a next larger element is found, store it
            // in the dictionary
            if (stack.Count > 0) {
                nextLarger[nodes[i]] = stack.Peek();
            }
            // If no next larger element is found, set the
            // value to -1
            else {
                nextLarger[nodes[i]] = -1;
            }
              stack.Push(nodes[i]);
        }
          return nextLarger;
    }
      public static void Main()
    {
        Node root = NewNode(8);
        root.children.Add(NewNode(3));
        root.children.Add(NewNode(10));
        root.children[0].children.Add(NewNode(1));
        root.children[0].children.Add(NewNode(6));
        root.children[0].children[1].children.Add(
            NewNode(4));
        root.children[0].children[1].children.Add(
            NewNode(7));
        root.children[1].children.Add(NewNode(14));
          int target = 4;
        Dictionary<int, int> nextLarger
            = FindNextLarger(root);
        int nextLargerValue;
        if (nextLarger.TryGetValue(target,
                                   out nextLargerValue)) {
            Console.WriteLine("The next larger element for "
                              + target
                              + " is: " + nextLargerValue);
        }
        else {
            Console.WriteLine("The next larger element for "
                              + target + " is: -1");
        }
    }
}
Javascript



class TreeNode {
    constructor(x) {
        this.val = x;
        this.children = [];
    }
}
  function postOrder(root, nodes) {
    if (!root) return;
    for (const child of root.children) {
        postOrder(child, nodes);
    }
    nodes.push(root.val);
}
  function findNextLarger(root) {
    const nodes = [];
    const nextLarger = new Map();
    postOrder(root, nodes);
      const stack = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
        while (stack.length > 0 && stack[stack.length - 1] <= nodes[i]) {
            stack.pop();
        }
        nextLarger.set(nodes[i], stack.length > 0 ? stack[stack.length - 1] : -1);
        stack.push(nodes[i]);
    }
      return nextLarger;
}
      const root = new TreeNode(8);
    root.children.push(new TreeNode(3));
    root.children.push(new TreeNode(10));
    root.children[0].children.push(new TreeNode(1));
    root.children[0].children.push(new TreeNode(6));
    root.children[0].children[1].children.push(new TreeNode(4));
    root.children[0].children[1].children.push(new TreeNode(7));
    root.children[1].children.push(new TreeNode(14));
      const target = 4;
    const nextLarger = findNextLarger(root);
    const nextLargerValue = nextLarger.get(target);
    console.log(`The next larger element for ${target} is: ${nextLargerValue !== undefined ? nextLargerValue : -1}`);
The next larger element for 4 is 7

Time and Space complexities are:
The time complexity of this algorithm is O(n), where n is the number of nodes in the n-ary tree. The reason for this is that we traverse each node in the tree once, and for each node, we perform a constant amount of work to find its next larger element.
The auxiliary space of this algorithm is O(n), where n is the number of nodes in the n-ary tree. The reason for this is that we use a stack to store the nodes in post-order and a hash map to store the next larger element for each node. The size of the stack and the hash map is proportional to the number of nodes in the tree, so their combined space complexity is O(n).
This article is contributed by Chhavi. If you like GeeksforGeeks and would like to contribute, you can also write an article using write.geeksforgeeks.org or mail your article to review-team@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks. 

Feeling lost in the world of random DSA topics, wasting time without progress? It's time for a change! Join our DSA course, where we'll guide you on an exciting journey to master DSA efficiently and on schedule.
You'll access excellent video content by our CEO, Sandeep Jain, tackle common interview questions, and engage in real-time coding contests covering various DSA topics. We're here to prepare you thoroughly for online assessments and interviews.
Ready to dive in? Explore our free demo content and join our DSA course, trusted by over 100,000 geeks! Whether it's DSA in C++, Java, Python, or JavaScript we've got you covered. Let's embark on this exciting journey together!

Last Updated : 16 Aug, 2023
2