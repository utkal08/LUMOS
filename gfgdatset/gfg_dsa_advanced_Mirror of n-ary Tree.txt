Mirror of n-ary Tree
Read
Discuss
Courses
Practice
Video
Given a Tree where every node contains variable number of children, convert the tree to its mirror. Below diagram shows an example. 
We strongly recommend you to minimize your browser and try this yourself first. 
Node of tree is represented as a key and a variable sized array of children pointers. The idea is similar to mirror of Binary Tree. For every node, we first recur for all of its children and then reverse array of children pointers. We can also do these steps in other way, i.e., reverse array of children pointers first and then recur for children.
Below is C++ implementation of above idea. 
C++



// C++ program to mirror an n-ary tree
#include <bits/stdc++.h>
using namespace std;
  // Represents a node of an n-ary tree
struct Node
{
    int key;
    vector<Node *>child;
};
  // Function to convert a tree to its mirror
void mirrorTree(Node * root)
{
    // Base case: Nothing to do if root is NULL
    if (root==NULL)
        return;
      // Number of children of root
    int n = root->child.size();
      // If number of child is less than 2 i.e.
    // 0 or 1 we do not need to do anything
    if (n < 2)
        return;
      // Calling mirror function for each child
    for (int i=0; i<n; i++)
        mirrorTree(root->child[i]);
      // Reverse vector (variable sized array) of child
    // pointers
    reverse(root->child.begin(), root->child.end());
}
  // Utility function to create a new tree node
Node *newNode(int key)
{
    Node *temp = new Node;
    temp->key = key;
    return temp;
}
  // Prints the n-ary tree level wise
void printNodeLevelWise(Node * root)
{
    if (root==NULL)
        return;
      // Create a queue and enqueue root to it
    queue<Node *>q;
    q.push(root);
      // Do level order traversal. Two loops are used
    // to make sure that different levels are printed
    // in different lines
    while (!q.empty())
    {
        int n = q.size();
        while (n>0)
        {
            // Dequeue an item from queue and print it
            Node * p = q.front();
            q.pop();
            cout << p->key << " ";
              // Enqueue all childrent of the dequeued item
            for (int i=0; i<p->child.size(); i++)
                q.push(p->child[i]);
            n--;
        }
          cout << endl; // Separator between levels
    }
}
  // Driver program
int main()
{
    /*   Let us create below tree
    *              10
    *        /   /    \   \
    *        2  34    56   100
    *                 |   /  | \
    *                 1   7  8  9
    */
    Node *root = newNode(10);
    (root->child).push_back(newNode(2));
    (root->child).push_back(newNode(34));
    (root->child).push_back(newNode(56));
    (root->child).push_back(newNode(100));
    (root->child[2]->child).push_back(newNode(1));
    (root->child[3]->child).push_back(newNode(7));
    (root->child[3]->child).push_back(newNode(8));
    (root->child[3]->child).push_back(newNode(9));
      cout << "Level order traversal Before Mirroring\n";
    printNodeLevelWise(root);
      mirrorTree(root);
      cout << "\nLevel order traversal After Mirroring\n";
    printNodeLevelWise(root);
      return 0;
}
Java



// Java code for the above approach
import java.util.*;
  // Represents a node of an n-ary tree
class Node
{
  int key;
  List<Node> child;
  public Node(int key)
  {
    this.key = key;
    child = new ArrayList<Node>();
  }
}
  class Main
{
    // Function to convert a tree to its mirror
  static void mirrorTree(Node root)
  {
      // Base case: Nothing to do if root is NULL
    if (root == null)
      return;
      // Number of children of root
    int n = root.child.size();
      // If number of child is less than 2 i.e.
    // 0 or 1 we do not need to do anything
    if (n < 2)
      return;
      // Calling mirror function for each child
    for (int i = 0; i < n; i++)
      mirrorTree(root.child.get(i));
      // Reverse vector (variable sized array) of child
    // pointers
    Collections.reverse(root.child);
  }
    // Utility function to create a new tree node
  public static Node newNode(int key)
  {
    Node temp = new Node(key);
    return temp;
  }
    // Prints the n-ary tree level wise
  static void printNodeLevelWise(Node root)
  {
    if (root == null)
      return;
      // Create a queue and enqueue root to it
    Queue<Node> q = new LinkedList<Node>();
    q.add(root);
      // Do level order traversal. Two loops are used
    // to make sure that different levels are printed
    // in different lines
    while (!q.isEmpty())
    {
      int n = q.size();
      while (n > 0)
      {
        // Dequeue an item from queue and print it
        Node p = q.poll();
        System.out.print(p.key + " ");
          // Enqueue all childrent of the dequeued item
        for (int i = 0; i < p.child.size(); i++)
          q.add(p.child.get(i));
        n--;
      }
        System.out.println(); // Separator between levels
    }
  }
    // Driver program
  public static void main(String[] args)
  {
    /*   Let us create below tree
        *              10
        *        /   /    \   \
        *        2  34    56   100
        *                 |   /  | \
        *                 1   7  8  9
        */
    Node root = newNode(10);
    root.child.add(newNode(2));
    root.child.add(newNode(34));
    root.child.add(newNode(56));
    root.child.add(newNode(100));
    root.child.get(2).child.add(newNode(1));
    root.child.get(3).child.add(newNode(7));
    root.child.get(3).child.add(newNode(8));
    root.child.get(3).child.add(newNode(9));
      System.out.println("Level order traversal Before Mirroring");
    printNodeLevelWise(root);
      mirrorTree(root);
      System.out.println("\nLevel order traversal After Mirroring");
    printNodeLevelWise(root);
  }
}
  // This code is contributed by lokeshpotta20.
Python3



# Python program to mirror an n-ary tree
  # Represents a node of an n-ary tree
class Node :
      # Utility function to create a new tree node
    def __init__(self ,key):
        self.key = key 
        self.child = []
    # Function to convert a tree to its mirror
def mirrorTree(root):
          # Base Case : nothing to do if root is None
    if root is None:
        return
          # Number of children of root 
    n = len(root.child)
      # If number of child is less than 2 i.e. 
    # 0 or 1 we don't need to do anything
    if n <2 :
        return
          # Calling mirror function for each child
    for i in range(n):
        mirrorTree(root.child[i]);
          # Reverse variable sized array of child pointers
    root.child.reverse()
        # Prints the n-ary tree level wise
  def printNodeLevelWise(root):
    if root is None:
        return
          # create a queue and enqueue root to it
    queue = []
    queue.append(root)
      # Do level order traversal. Two loops are used
    # to make sure that different levels are printed
    # in different lines
    while(len(queue) >0):
          n = len(queue)
        while(n > 0) :
              # Dequeue an item from queue and print it
            p = queue[0]
            queue.pop(0)
            print(p.key,end=" ")
                  # Enqueue all children of the dequeued item
            for index, value in enumerate(p.child):
                queue.append(value)
              n -= 1
        print() # Separator between levels
            # Driver Program
      """   Let us create below tree
    *              10
    *        /   /    \   \
    *        2  34    56   100
    *                 |   /  | \
    *                 1   7  8  9
    """
  root = Node(10)
root.child.append(Node(2))
root.child.append(Node(34))
root.child.append(Node(56))
root.child.append(Node(100))
root.child[2].child.append(Node(1))
root.child[3].child.append(Node(7))
root.child[3].child.append(Node(8))
root.child[3].child.append(Node(9))
  print ("Level order traversal Before Mirroring")
printNodeLevelWise(root)
  mirrorTree(root)
      print ("\nLevel Order traversal After Mirroring")
printNodeLevelWise(root)
C#



// C# code for the above approach
using System;
using System.Collections.Generic;
  // Represents a node of an n-ary tree
public class Node {
  public int key;
  public List<Node> child;
    public Node(int key)
  {
    this.key = key;
    child = new List<Node>();
  }
}
  public class GFG {
    // Function to convert a tree to its mirror
  static void MirrorTree(Node root)
  {
    // Base case: Nothing to do if root is NULL
    if (root == null)
      return;
      // Number of children of root
    int n = root.child.Count;
      // If number of child is less than 2 i.e.
    // 0 or 1 we do not need to do anything
    if (n < 2)
      return;
      // Calling mirror function for each child
    for (int i = 0; i < n; i++)
      MirrorTree(root.child[i]);
      // Reverse list of child
    root.child.Reverse();
  }
    // Utility function to create a new tree node
  public static Node NewNode(int key)
  {
    Node temp = new Node(key);
    return temp;
  }
    // Prints the n-ary tree level wise
  static void PrintNodeLevelWise(Node root)
  {
    if (root == null)
      return;
      // Create a queue and enqueue root to it
    Queue<Node> q = new Queue<Node>();
    q.Enqueue(root);
      // Do level order traversal. Two loops are used
    // to make sure that different levels are printed
    // in different lines
    while (q.Count > 0) {
      int n = q.Count;
      while (n > 0) {
        // Dequeue an item from queue and print it
        Node p = q.Dequeue();
        Console.Write(p.key + " ");
          // Enqueue all children of the dequeued item
        for (int i = 0; i < p.child.Count; i++)
          q.Enqueue(p.child[i]);
        n--;
      }
        Console.WriteLine(); // Separator between levels
    }
  }
    static public void Main()
  {
      /* Let us create below tree
         *           10
         *     / / \ \
         *     2 34 56 100
         *             | / | \
         *             1 7 8 9
         */
    Node root = NewNode(10);
    root.child.Add(NewNode(2));
    root.child.Add(NewNode(34));
    root.child.Add(NewNode(56));
    root.child.Add(NewNode(100));
    root.child[2].child.Add(NewNode(1));
    root.child[3].child.Add(NewNode(7));
    root.child[3].child.Add(NewNode(8));
    root.child[3].child.Add(NewNode(9));
      Console.WriteLine(
      "Level order traversal Before Mirroring");
    PrintNodeLevelWise(root);
    MirrorTree(root);
      Console.WriteLine(
      "\nLevel order traversal After Mirroring");
    PrintNodeLevelWise(root);
  }
}
  // This code is contributed by lokeshmvs21.
Javascript



   // Javascript program to mirror an n-ary tree
  // Represents a node of an n-ary tree
class Node
{
  constructor()
  {
    this.key = 0;
    this.child = []
  }
};
  // Function to convert a tree to its mirror
function mirrorTree(root)
{
    // Base case: Nothing to do if root is null
    if (root==null)
        return;
      // Number of children of root
    var n = root.child.length;
      // If number of child is less than 2 i.e.
    // 0 or 1 we do not need to do anything
    if (n < 2)
        return;
      // Calling mirror function for each child
    for(var i=0; i<n; i++)
        mirrorTree(root.child[i]);
      // Reverse vector (variable sized array) of child
    // pointers
    root.child.reverse();
}
  // Utility function to create a new tree node
function newNode(key)
{
    var temp = new Node;
    temp.key = key;
    return temp;
}
  // Prints the n-ary tree level wise
function printNodeLevelWise(root)
{
    if (root==null)
        return;
      // Create a queue and enqueue root to it
    var q = [];
    q.push(root);
      // Do level order traversal. Two loops are used
    // to make sure that different levels are printed
    // in different lines
    while (q.length!=0)
    {
        var n = q.length;
        while (n>0)
        {
            // Dequeue an item from queue and print it
            var p = q[0];
            q.shift();
            document.write( p.key + " ");
              // Enqueue all childrent of the dequeued item
            for(var i=0; i<p.child.length; i++)
                q.push(p.child[i]);
            n--;
        }
          document.write("<br>") // Separator between levels
    }
}
  // Driver program
/*   Let us create below tree
*              10
*        /   /    \   \
*        2  34    56   100
*                 |   /  | \
*                 1   7  8  9
*/
var root = newNode(10);
(root.child).push(newNode(2));
(root.child).push(newNode(34));
(root.child).push(newNode(56));
(root.child).push(newNode(100));
(root.child[2].child).push(newNode(1));
(root.child[3].child).push(newNode(7));
(root.child[3].child).push(newNode(8));
(root.child[3].child).push(newNode(9));
document.write("Level order traversal Before Mirroring<br>");
printNodeLevelWise(root);
mirrorTree(root);
document.write("<br>Level order traversal After Mirroring<br>");
printNodeLevelWise(root);
  // This code is contributed by rrrtnx.
Output
Level order traversal Before Mirroring
10 
2 34 56 100 
1 7 8 9 

Level order traversal After Mirroring
10 
100 56 34 2 
9 8 7 1 
Time Complexity: O(N) here N is number of nodes
Auxiliary Space: O(N) ,here N is number of nodes

Feeling lost in the world of random DSA topics, wasting time without progress? It's time for a change! Join our DSA course, where we'll guide you on an exciting journey to master DSA efficiently and on schedule.
You'll access excellent video content by our CEO, Sandeep Jain, tackle common interview questions, and engage in real-time coding contests covering various DSA topics. We're here to prepare you thoroughly for online assessments and interviews.
Ready to dive in? Explore our free demo content and join our DSA course, trusted by over 100,000 geeks! Whether it's DSA in C++, Java, Python, or JavaScript we've got you covered. Let's embark on this exciting journey together!

Last Updated : 13 Feb, 2023
8