Disjoint Set Union on Trees
Read
Discuss
Courses
Practice
Given a tree and weights of nodes. Weights are non-negative integers. Task is to find maximum size of a subtree of a given tree such that all nodes are even in weights.
Prerequisite : Disjoint Set Union
Examples : 
Input : Number of nodes = 7
        Weights of nodes = 1 2 6 4 2 0 3
        Edges = (1, 2), (1, 3), (2, 4), 
                (2, 5), (4, 6), (6, 7)
Output : Maximum size of the subtree 
with even weighted nodes = 4 
Explanation : 
Subtree of nodes {2, 4, 5, 6} gives the maximum size.

Input : Number of nodes = 6
        Weights of nodes = 2 4 0 2 2 6
        Edges = (1, 2), (2, 3), (3, 4), 
                (4, 5), (1, 6)
Output : Maximum size of the subtree
with even weighted nodes = 6
Explanation : 
The given tree gives the maximum size.
Approach: 
We can find solution by simply running DFS on tree. DFS solution gives us answer in O(n). But, how can we use DSU for this problem? 
We first iterate through all edges. If both nodes are even in weights, we make union of them. Set of nodes with maximum size is the answer. If we use union-find with path compression then time complexity is O(n).
Below is the implementation of above approach :  
C++
Java
Python3
C#
Javascript



// CPP code to find maximum subtree such
// that all nodes are even in weight
#include<bits/stdc++.h>
  using namespace std;
  #define N 100010
  // Structure for Edge
struct Edge 
{
    int u, v;
};
  /*
    'id': stores parent of a node.
    'sz': stores size of a DSU tree.
*/
int id[N], sz[N];
  // Function to assign root
int Root(int idx)
{
    int i = idx;
          while(i != id[i]) 
        id[i] = id[id[i]], i = id[i];
          return i;
}
  // Function to find Union
void Union(int a, int b)
{
    int i = Root(a), j = Root(b);
          if (i != j)
    {
        if(sz[i] >= sz[j])
        {
            id[j] = i, sz[i] += sz[j];
            sz[j] = 0;
        }
        else
        {
            id[i] = j, sz[j] += sz[i];
            sz[i] = 0;
        }
    }
}
  // Utility function for Union
void UnionUtil(struct Edge e[], int W[], int q)
{
      for(int i = 0; i < q; i++)
    {
        // Edge between 'u' and 'v'
        int u, v;
        u = e[i].u, v = e[i].v;
          // 0-indexed nodes
        u--, v--;
          // If weights of both 'u' and 'v' 
        // are even then we make union of them.
        if(W[u] % 2 == 0 && W[v] % 2 == 0) 
                    Union(u,v);
    }
}
  // Function to find maximum
// size of DSU tree
int findMax(int n, int W[])
{
    int maxi = 0;
    for(int i = 1; i <= n; i++) 
        if(W[i] % 2 == 0) 
            maxi = max(maxi, sz[i]);   
                  return maxi;
}
  // Driver code
int main()
{
    /*
        Nodes are 0-indexed in this code
        So we have to make necessary changes
        while taking inputs
    */
      // Weights of nodes
    int W[] = {1, 2, 6, 4, 2, 0, 3};
      // Number of nodes in a tree
    int n = sizeof(W) / sizeof(W[0]);
      // Initializing every node as
    // a tree with single node.
    for(int i = 0; i < n; i++) 
            id[i] = i, sz[i] = 1;
      Edge e[] = {{1, 2}, {1, 3}, {2, 4}, 
                {2, 5}, {4, 6}, {6, 7}};
      int q = sizeof(e) / sizeof(e[0]);
      UnionUtil(e, W, q);
      // Find maximum size of DSU tree.
    int maxi = findMax(n, W);
      printf("Maximum size of the subtree with "); 
    printf("even weighted nodes = %d\n", maxi);
          return 0;
}












Output
Maximum size of the subtree with even weighted nodes = 4
Time complexity : O(q log n) where q is the number of edges and n is the number of nodes.
Space Complexity : O(n)

Feeling lost in the world of random DSA topics, wasting time without progress? It's time for a change! Join our DSA course, where we'll guide you on an exciting journey to master DSA efficiently and on schedule.
You'll access excellent video content by our CEO, Sandeep Jain, tackle common interview questions, and engage in real-time coding contests covering various DSA topics. We're here to prepare you thoroughly for online assessments and interviews.
Ready to dive in? Explore our free demo content and join our DSA course, trusted by over 100,000 geeks! Whether it's DSA in C++, Java, Python, or JavaScript we've got you covered. Let's embark on this exciting journey together!

Last Updated : 05 Mar, 2023