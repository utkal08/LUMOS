Introduction to Segment Trees – Data Structure and Algorithm Tutorials
Read
Discuss
Courses
Practice
What is Segment Tree?
A Segment Tree is a data structure that stores information about a range of elements in its nodes. It also allows users to modify the array and perform range queries in smaller complexity. For example, we can perform a range summation of an array between the range L to R while also modifying the array from range L to R all in log(N) time complexity.
Types of Operations:
The operations that the segment tree can perform must be binary and associative. Overall the values must belong to the set of the semigroup. The neutral element must be obvious according to the type of operation and semigroup we are looking for. For example, if we want to find the sum over the range of values in an array where the elements belong to  then the neutral element, in this case, will be 0. Some of the examples of operations are:
Addition/Subtraction
Maximum/Minimum
GCD/LCM
AND/OR/XOR
Structure of the Tree
The segment tree works on the principle of divide and conquer. 
At each level, we divide the array segments into two parts. If the given array had [0, . . ., N-1] elements in it then the two parts of the array will be [0, . . ., N/2-1] and [N/2, . . ., N-1]. 
We will then recursively go on until the lower and upper bounds of the range become equal. 
The structure of the segment tree looks like a binary tree.
The segment tree is generally represented using an array where the first value stores the value for the total array range and the child of the node at the ith index are at (2*i + 1) and (2*i + 2).
Constructing the segment tree:
There are two important points to be noted while constructing the segment tree:
Choosing what value to be stored in the nodes according to the problem definition
What should the merge operation do
If the problem definition states that we need to calculate the sum over ranges, then the value at nodes should store the sum of values over the ranges.
The child node values are merged back into the parent node to hold the value for that particular range, [i.e., the range covered by all the nodes of its subtree]. 
In the end, leaf nodes store information about a single element. All the leaf nodes store the array based on which the segment tree is built. 
Following are the steps for constructing a segment tree:
Start from the leaves of the tree
Recursively build the parents from the merge operation
The merge operation will take constant time if the operator takes constant time. SO building the whole tree takes O(N) time.
Segment tree
Range Query
Let us understand this with the help of the following problem
Given two integers L and R return the sum of the segment [L, R]
The first step is constructing the segment tree with the addition operator and 0 as the neutral element. 
If the range is one of the node’s range values then simply return the answer.
Otherwise, we will need to traverse the left and right children of the nodes and recursively continue the process till we find a node that covers a range that totally covers a part or whole of the range [L, R]
While returning from each call, we need to merge the answers received from each of its child.
As the height of the segment tree is logN the query time will be O(logN) per query.
Range Query in Segment Tree
Point Updates
Given an index,  idx, update the value of the array at index idx with value V
The element’s contribution is only in the path from its leaf to its parent. Thus only logN elements will get affected due to the update.
For updating, traverse till the leaf that stores the value of index idx and update the value. Then while tracing back in the path, modify the ranges accordingly. 
The time complexity will be O(logN).
Point Update in Segment Tree
Below is the implementation of construction, query, and point update for a segment tree:
C++
Java
Python3
C#
Javascript



// C++ code for segment tree with sum
// range and update query
  #include <bits/stdc++.h>
using namespace std;
vector<int> A, ST;
  void build(int node, int L, int R)
{
      // Leaf node where L == R
    if (L == R) {
        ST[node] = A[L];
    }
    else {
          // Find the middle element to
        // split the array into two halves
        int mid = (L + R) / 2;
          // Recursively travel the
        // left half
        build(2 * node, L, mid);
          // Recursively travel the
        // right half
        build(2 * node + 1, mid + 1, R);
          // Storing the sum of both the
        // children into the parent
        ST[node] = ST[2 * node] + ST[2 * node + 1];
    }
}
  void update(int node, int L, int R, int idx, int val)
{
      // Find the lead node and
    // update its value
    if (L == R) {
        A[idx] += val;
        ST[node] += val;
    }
    else {
          // Find the mid
        int mid = (L + R) / 2;
          // If node value idx is at the
        // left part then update
        // the left part
        if (L <= idx and idx <= mid)
            update(2 * node, L, mid, idx, val);
        else
            update(2 * node + 1, mid + 1, R, idx, val);
          // Store the information in parents
        ST[node] = ST[2 * node] + ST[2 * node + 1];
    }
}
  int query(int node, int tl, int tr, int l, int r)
{
      // If it lies out of range then
    // return 0
    if (r < tl or tr < l)
        return 0;
      // If the node contains the range then
    // return the node value
    if (l <= tl and tr <= r)
        return ST[node];
    int tm = (tl + tr) / 2;
      // Recursively traverse left and right
    // and find the node
    return query(2 * node, tl, tm, l, r)
           + query(2 * node + 1, tm + 1, tr, l, r);
}
  // Driver code
int main()
{
    int n = 6;
    A = { 0, 1, 3, 5, -2, 3 };
      // Create a segment tree of size 4*n
    ST.resize(4 * n);
      // Build a segment tree
    build(1, 0, n - 1);
    cout << "Sum of values in range 0-4 are: "
         << query(1, 0, n - 1, 0, 4) << "\n";
      // Update the value at idx = 1 by
    // 100 thus becoming 101
    update(1, 0, n - 1, 1, 100);
    cout << "Value at index 1 increased by 100\n";
    cout << "sum of value in range 1-3 are: "
         << query(1, 0, n - 1, 1, 3) << "\n";
      return 0;
}












Output
Sum of values in range 0-4 are: 7
Value at index 1 increased by 100
sum of value in range 1-3 are: 109
Time complexity: O(N)
The building operation takes O(N) time
The query operation takes O(logN) time
Each update is performed in O(logN) time
Auxiliary Space: O(n)
Note:
A segment tree with 2^x leaf nodes will have 2^(x+1)-1 total nodes due to its perfect binary tree structure. However, when dealing with a non-power-of-two number of elements, extra leaf nodes may be present. To represent all elements, the number of leaf nodes must be rounded up to the nearest power of two, resulting in a maximum of almost 2*n leaf nodes.
For instance, if n is 2^j + 1, 2^(j+1) leaf nodes will be required, leading to an O(2*n) space complexity. As the total number of nodes is about twice the number of leaf nodes, the total space complexity of the segment tree is O(4n). The space requirement can be substantial, but it is usually manageable for most practical applications.
Updating an interval (Lazy propagation):
Lazy Propagation: A speedup technique for range updates
Example of segment tree
We can delay some updates (avoid recursive calls in update) and do such updates only when necessary when there are several updates and updates are being performed on a range.
A node in a segment tree stores or displays the results of a query for a variety of indexes. 
Additionally, all of the node’s descendants must also be updated if the update operation’s range includes this node. 
Take the node with the value 27 in the picture above as an example. This node contains the sum of values at the indexes 3 to 5. This node and all of its descendants must be updated if our update query covers the range of 2 to 5.
By storing this update information in distinct nodes referred to as lazy nodes or values, we use lazy propagation to update only the node with value 27 and delay updates to its descendants. 
We make an array called lazy[] to stand in for the lazy node. The size of lazy[] is the same as the array used to represent the segment tree in the code following, which is tree[].
The goal is to set all of the lazy[elements] to 0. 
There are no pending changes on the segment tree node i if lazy[i] has a value of 0. 
A non-zero value for lazy[i] indicates that before doing any queries on node i in the segment tree, this sum needs to be added to the node.
Below is the implementation to demonstrate the working of Lazy Propagation.
C++
Java
Python3
C#
Javascript



// Program to show segment tree to
// demonstrate lazy propagation
#include <bits/stdc++.h>
using namespace std;
#define MAX 1000
  // Ideally, we should not use global
// variables and large constant-sized
// arrays, we have done it here for
// simplicity.
  // To store segment tree
int tree[MAX] = { 0 };
  // To store pending updates
int lazy[MAX] = { 0 };
  // si -> index of current node in segment tree
// ss and se -> Starting and ending
// indices of elements for which current
// nodes stores sum.
// us and ue -> starting and ending indexes
// of update query
// diff -> which we need to add in the
// range us to ue
void updateRangeUtil(int si, int ss, int se, int us, int ue,
                     int diff)
{
   // If lazy value is non-zero for
    // current node of segment tree, then
    // there are some pending updates. So,
    // we need to make sure that the
    // pending updates are done before
    // making new updates. Because this
    // value may be used by parent after
    // recursive calls (See last line
    // of this function)
    if (lazy[si] != 0) {
          // Make pending updates using
        // value stored in lazy nodes
        tree[si] += (se - ss + 1) * lazy[si];
          // checking if it is not leaf node
        // because if it is leaf node then
        // we cannot go further
        if (ss != se) {
              // We can postpone updating
            // children we don't need
            // their new values now. Since
            // we are not yet updating
            // children of si, we need to
            // set lazy flags for the children
            lazy[si * 2 + 1] += lazy[si];
            lazy[si * 2 + 2] += lazy[si];
        }
          // Set the lazy value for current
        // node as 0 as it has been updated
        lazy[si] = 0;
    }
      // out of range
    if (ss > se || ss > ue || se < us)
        return;
      // Current segment is fully in range
    if (ss >= us && se <= ue) {
          // Add the difference to
        // current node
        tree[si] += (se - ss + 1) * diff;
          // Same logic for checking
        // leaf node or not
        if (ss != se) {
              // This is where we store
            // values in lazy nodes,
            // rather than updating the
            // segment tree itself Since
            // we don't need these updated
            // values now we postpone
            // updates by storing values
            // in lazy[]
            lazy[si * 2 + 1] += diff;
            lazy[si * 2 + 2] += diff;
        }
        return;
    }
      // If not completely in rang,
    // but overlaps, recur for children,
    int mid = (ss + se) / 2;
    updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);
    updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);
      // And use the result of children
    // calls to update this node
    tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
}
  // Function to update a range of values
// in segment tree
// us and eu -> starting and ending
// indices of update query
// ue -> ending index of update query
// diff -> which we need to add in the
// range us to ue
void updateRange(int n, int us, int ue, int diff)
{
    updateRangeUtil(0, 0, n - 1, us, ue, diff);
}
  // A recursive function to get the sum of
// values in given range of the array.
// The following are parameters for this function.
// si --> Index of current node in the st.
// Initially 0 is passed as root is always
// at' index 0
// ss & se --> Starting and ending indices
// of the segment represented by current
// node, i.e., tree[si]
// qs & qe --> Starting and ending
// indices of query range
int getSumUtil(int ss, int se, int qs, int qe, int si)
{
      // If lazy flag is set for current
    // node of segment tree, then there
    // are some pending updates. So we
    // need to make sure that the pending
    // updates are done before
    // processing the sub sum query
    if (lazy[si] != 0) {
          // Make pending updates to this
        // node. Note that this node
        // represents sum of elements in
        // arr[ss..se]  and all these
        // elements must be increased by
        // lazy[si]
        tree[si] += (se - ss + 1) * lazy[si];
          // Checking if it is not leaf node
        // because if it is leaf node then
        // we cannot go further
        if (ss != se) {
              // Since we are not yet
            // updating children os si,
            // we need to set lazy values
            // for the children
            lazy[si * 2 + 1] += lazy[si];
            lazy[si * 2 + 2] += lazy[si];
        }
          // unset the lazy value for current
        // node as it has been updated
        lazy[si] = 0;
    }
      // Out of range
    if (ss > se || ss > qe || se < qs)
        return 0;
      // At this point we are sure that
    // pending lazy updates are done for
    // current node. So we can return
    // value
      // If this segment lies in range
    if (ss >= qs && se <= qe)
        return tree[si];
      // If a part of this segment overlaps
    // with the given range
    int mid = (ss + se) / 2;
    return getSumUtil(ss, mid, qs, qe, 2 * si + 1)
           + getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);
}
  // Return sum of elements in range from
// index qs (query start) to qe (query end).
// It mainly uses getSumUtil()
int getSum(int n, int qs, int qe)
{
      // Check for erroneous input values
    if (qs < 0 || qe > n - 1 || qs > qe) {
        cout << "Invalid Input";
        return -1;
    }
      return getSumUtil(0, n - 1, qs, qe, 0);
}
  // A recursive function that constructs
// Segment Tree for array[ss..se].
// si is index of current node in st.
void constructSTUtil(int arr[], int ss, int se, int si)
{
      // Out of range as ss can never
    // be greater than se
    if (ss > se)
        return;
      // If there is one element in array,
    // store it in current node of segment
    // tree and return
    if (ss == se) {
        tree[si] = arr[ss];
        return;
    }
      // If there are more than one elements,
    // then recur for left and right
    // subtrees and store the sum of
    // values in this node
    int mid = (ss + se) / 2;
    constructSTUtil(arr, ss, mid, si * 2 + 1);
    constructSTUtil(arr, mid + 1, se, si * 2 + 2);
      tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
}
  // Function to construct segment tree
// from given array.This function allocates
// memory for segment tree and calls
// constructSTUtil() to fill the
// allocated memory
void constructST(int arr[], int n)
{
      // Fill the allocated memory st
    constructSTUtil(arr, 0, n - 1, 0);
}
  // Driver program to test above functions
int main()
{
    int arr[] = { 1, 3, 5, 7, 9, 11 };
    int n = sizeof(arr) / sizeof(arr[0]);
      // Build segment tree from given array
    constructST(arr, n);
      // Print sum of values in array
    // from index 1 to 3
    cout << "Sum of values in given range = " << getSum(n, 1, 3) << endl;
      // Add 10 to all nodes at indexes
    // from 1 to 5.
    updateRange(n, 1, 5, 10);
      // Find sum after the value is updated
    cout << "Updated sum of values in given range = " << getSum(n, 1, 3) << endl;
      return 0;
}












Output
Sum of values in given range = 15
Updated sum of values in given range = 45
Time Complexity: O(N)
Auxiliary Space: O(MAX)
Applications:
Interval scheduling: Segment trees can be used to efficiently schedule non-overlapping intervals, such as scheduling appointments or allocating resources.
Range-based statistics: Segment trees can be used to compute range-based statistics such as variance, standard deviation, and percentiles.
Image processing: Segment trees are used in image processing algorithms to divide an image into segments based on color, texture, or other attributes.
Advantages:
Efficient querying: Segment trees can be used to efficiently answer queries about the minimum, maximum, sum, or other aggregate value of a range of elements in an array.
Efficient updates: Segment trees can be used to efficiently update a range of elements in an array, such as incrementing or decrementing a range of values.
Flexibility: Segment trees can be used to solve a wide variety of problems involving range queries and updates.
Disadvantages:
Complexity: Segment trees can be complex to implement and maintain, especially for large arrays or high-dimensional data.
Time complexity: The time complexity of segment tree operations like build, update, and the query is O(log N) , which is higher than some other data structures like the Fenwick tree.
Space complexity: The space complexity of a segment tree is O(4N) which is relatively high.

Feeling lost in the world of random DSA topics, wasting time without progress? It's time for a change! Join our DSA course, where we'll guide you on an exciting journey to master DSA efficiently and on schedule.
You'll access excellent video content by our CEO, Sandeep Jain, tackle common interview questions, and engage in real-time coding contests covering various DSA topics. We're here to prepare you thoroughly for online assessments and interviews.
Ready to dive in? Explore our free demo content and join our DSA course, trusted by over 100,000 geeks! Whether it's DSA in C++, Java, Python, or JavaScript we've got you covered. Let's embark on this exciting journey together!

Last Updated : 05 May, 2023
6